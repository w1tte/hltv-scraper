---
phase: 07-performance-and-economy-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - migrations/004_performance_economy.sql
  - src/scraper/repository.py
  - src/scraper/config.py
  - src/scraper/map_stats.py
autonomous: true

must_haves:
  truths:
    - "Re-running Phase 6 now persists opening_kills, opening_deaths, multi_kills, clutch_wins, traded_deaths, and round_swing into player_stats (previously silently dropped)"
    - "Database schema has columns for opening_kills, opening_deaths, multi_kills, clutch_wins, traded_deaths, round_swing, mk_rating on player_stats table"
    - "kill_matrix table exists with correct PK and FK constraints"
    - "Repository can query maps pending performance/economy extraction"
    - "Repository can atomically upsert performance data, economy data, and kill matrix data"
    - "Repository can query valid round numbers from round_history for a given map"
  artifacts:
    - path: "migrations/004_performance_economy.sql"
      provides: "Schema migration adding missing columns and kill_matrix table"
      contains: "ALTER TABLE player_stats ADD COLUMN opening_kills"
    - path: "src/scraper/repository.py"
      provides: "Extended UPSERT SQL and new methods for Phase 7"
      exports: ["UPSERT_KILL_MATRIX", "GET_PENDING_PERF_ECONOMY"]
    - path: "src/scraper/config.py"
      provides: "perf_economy_batch_size config field"
      contains: "perf_economy_batch_size"
    - path: "src/scraper/map_stats.py"
      provides: "Updated orchestrator dict mapping with new columns"
      contains: "opening_kills"
  key_links:
    - from: "migrations/004_performance_economy.sql"
      to: "src/scraper/repository.py"
      via: "UPSERT SQL references new columns added by migration"
      pattern: "opening_kills|mk_rating|kill_matrix"
    - from: "src/scraper/repository.py"
      to: "src/scraper/map_stats.py"
      via: "Orchestrator uses UPSERT_PLAYER_STATS which now includes new columns"
      pattern: "opening_kills.*ps\\.opening_kills"
---

<objective>
Add database schema support for Phase 7 data and extend the repository layer with the queries and UPSERT operations needed by the performance and economy parsers.

Purpose: The existing schema lacks columns for several fields already extracted by the Phase 6 parser (opening_kills, opening_deaths, multi_kills, clutch_wins, traded_deaths, round_swing) and new Phase 7 fields (mk_rating). A kill_matrix table is also needed. The repository needs pending-state queries and batch upsert methods for performance, economy, and kill matrix data. The Phase 6 orchestrator must be updated to persist the newly-available columns.

NOTE: The opening_kills/deaths and multi-kill data referenced in the roadmap Success Criterion 1 are extracted from the map stats page (Phase 6 parser), NOT the performance page. The Phase 6 parser already extracts these fields into the PlayerStats dataclass but the orchestrator silently dropped them because the DB columns did not exist. This plan adds the columns and updates the Phase 6 orchestrator to persist them.

Output: Migration 004 applied, repository extended, config updated, Phase 6 orchestrator updated.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-performance-and-economy-extraction/07-RESEARCH.md

# Existing files to modify
@src/scraper/repository.py
@src/scraper/config.py
@src/scraper/map_stats.py
@src/scraper/db.py
@migrations/001_initial_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema migration and config extension</name>
  <files>migrations/004_performance_economy.sql, src/scraper/config.py</files>
  <action>
Create `migrations/004_performance_economy.sql` with:

1. ALTER TABLE player_stats to add missing columns (these fields are already extracted by Phase 6 parser but silently dropped):
   - `opening_kills INTEGER`
   - `opening_deaths INTEGER`
   - `multi_kills INTEGER`
   - `clutch_wins INTEGER`
   - `traded_deaths INTEGER`
   - `round_swing REAL` (Rating 3.0 only, nullable)

2. ALTER TABLE player_stats to add Phase 7 performance page column:
   - `mk_rating REAL` (Rating 3.0 MK rating, nullable)

3. CREATE TABLE kill_matrix:
   ```sql
   CREATE TABLE IF NOT EXISTS kill_matrix (
       match_id      INTEGER NOT NULL,
       map_number    INTEGER NOT NULL,
       matrix_type   TEXT NOT NULL,          -- "all", "first_kill", "awp"
       player1_id    INTEGER NOT NULL,       -- Row player
       player2_id    INTEGER NOT NULL,       -- Column player
       player1_kills INTEGER NOT NULL,       -- Row player's kills against column player
       player2_kills INTEGER NOT NULL,       -- Column player's kills against row player
       scraped_at    TEXT NOT NULL,
       updated_at    TEXT NOT NULL,
       source_url    TEXT,
       parser_version TEXT,
       PRIMARY KEY (match_id, map_number, matrix_type, player1_id, player2_id),
       FOREIGN KEY (match_id, map_number) REFERENCES maps(match_id, map_number)
   );
   CREATE INDEX IF NOT EXISTS idx_kill_matrix_players ON kill_matrix(player1_id, player2_id);
   ```

4. In `src/scraper/config.py`, add `perf_economy_batch_size: int = 10` to the ScraperConfig dataclass (after `map_stats_batch_size`). Add a comment: "Maps per batch for performance+economy extraction".
  </action>
  <verify>
Run `python -c "from scraper.db import Database; db = Database(':memory:'); db.initialize(); print('Schema version:', db.get_schema_version()); cur = db.conn.execute('PRAGMA table_info(player_stats)'); cols = [r[1] for r in cur]; assert 'opening_kills' in cols; assert 'mk_rating' in cols; cur2 = db.conn.execute('PRAGMA table_info(kill_matrix)'); km_cols = [r[1] for r in cur2]; assert 'matrix_type' in km_cols; print('All columns verified'); db.close()"` succeeds.
  </verify>
  <done>Migration 004 creates all 7 new player_stats columns and kill_matrix table. Config has perf_economy_batch_size field. Schema version is 4.</done>
</task>

<task type="auto">
  <name>Task 2: Repository extension and Phase 6 orchestrator update</name>
  <files>src/scraper/repository.py, src/scraper/map_stats.py</files>
  <action>
**In `src/scraper/repository.py`:**

1. Update `UPSERT_PLAYER_STATS` SQL constant to include the 7 new columns in both INSERT and ON CONFLICT clauses:
   - Add to INSERT column list: `opening_kills, opening_deaths, multi_kills, clutch_wins, traded_deaths, round_swing, mk_rating`
   - Add to VALUES: `:opening_kills, :opening_deaths, :multi_kills, :clutch_wins, :traded_deaths, :round_swing, :mk_rating`
   - Add to ON CONFLICT DO UPDATE SET: `opening_kills = excluded.opening_kills, opening_deaths = excluded.opening_deaths, multi_kills = excluded.multi_kills, clutch_wins = excluded.clutch_wins, traded_deaths = excluded.traded_deaths, round_swing = excluded.round_swing, mk_rating = excluded.mk_rating`

2. Add `UPSERT_KILL_MATRIX` SQL constant (module-level, same style as others):
   ```sql
   INSERT INTO kill_matrix (
       match_id, map_number, matrix_type, player1_id, player2_id,
       player1_kills, player2_kills,
       scraped_at, updated_at, source_url, parser_version
   ) VALUES (
       :match_id, :map_number, :matrix_type, :player1_id, :player2_id,
       :player1_kills, :player2_kills,
       :scraped_at, :scraped_at, :source_url, :parser_version
   )
   ON CONFLICT(match_id, map_number, matrix_type, player1_id, player2_id) DO UPDATE SET
       player1_kills  = excluded.player1_kills,
       player2_kills  = excluded.player2_kills,
       updated_at     = excluded.scraped_at,
       source_url     = excluded.source_url,
       parser_version = excluded.parser_version
   ```

3. Add `GET_PENDING_PERF_ECONOMY` SQL constant:
   ```sql
   SELECT m.match_id, m.map_number, m.mapstatsid
   FROM maps m
   WHERE m.mapstatsid IS NOT NULL
     AND EXISTS (
       SELECT 1 FROM player_stats ps
       WHERE ps.match_id = m.match_id AND ps.map_number = m.map_number
     )
     AND EXISTS (
       SELECT 1 FROM player_stats ps
       WHERE ps.match_id = m.match_id AND ps.map_number = m.map_number
         AND ps.kpr IS NULL
     )
   ORDER BY m.match_id, m.map_number
   LIMIT ?
   ```
   This finds maps where Phase 6 has run (player_stats exist) but Phase 7 hasn't (kpr is NULL).

4. Add `get_pending_perf_economy(self, limit: int = 10) -> list[dict]` method to MatchRepository (same pattern as `get_pending_map_stats`).

5. Add `get_valid_round_numbers(self, match_id: int, map_number: int) -> set[int]` method to MatchRepository:
   ```python
   def get_valid_round_numbers(self, match_id: int, map_number: int) -> set[int]:
       """Return set of round numbers that exist in round_history for this map."""
       rows = self.conn.execute(
           "SELECT round_number FROM round_history "
           "WHERE match_id = ? AND map_number = ?",
           (match_id, map_number),
       ).fetchall()
       return {r[0] for r in rows}
   ```
   This is needed by the Phase 7 orchestrator to filter economy rows to only valid round numbers before inserting (avoiding FK constraint violations).

6. Add `upsert_perf_economy_complete(self, perf_stats: list[dict], economy_data: list[dict], kill_matrix_data: list[dict]) -> None` method:
   - Atomic transaction (`with self.conn:`)
   - Loop over perf_stats executing UPSERT_PLAYER_STATS (this UPDATES existing rows with kpr, dpr, impact, mk_rating values)
   - Loop over economy_data executing UPSERT_ECONOMY
   - Loop over kill_matrix_data executing UPSERT_KILL_MATRIX
   - Add `upsert_kill_matrix(self, data: dict) -> None` single-row method too (for consistency)

**In `src/scraper/map_stats.py`:**

7. Update the dict construction in the parse+persist loop (around line 110-133) to include the 7 new columns. Add these keys to the `stats_data.append({...})` dict:
   ```python
   "opening_kills": ps.opening_kills,
   "opening_deaths": ps.opening_deaths,
   "multi_kills": ps.multi_kills,
   "clutch_wins": ps.clutch_wins,
   "traded_deaths": ps.traded_deaths,
   "round_swing": ps.round_swing,
   "mk_rating": None,  # Still Phase 7 -- performance page hasn't been scraped yet
   ```
   These 6 fields (not mk_rating) are already extracted by `map_stats_parser.py` into the PlayerStats dataclass but were silently dropped. Now they get persisted.

IMPORTANT: The UPSERT_PLAYER_STATS now expects all 7 new keys in the dict. Both Phase 6 (map_stats.py) and Phase 7 (future orchestrator) will pass these keys. Phase 6 sets mk_rating=None; Phase 7 sets opening_kills etc. to the existing values (preserving them via UPSERT ON CONFLICT).
  </action>
  <verify>
Run `pytest tests/test_map_stats.py tests/test_repository.py -v --tb=short` -- all existing tests must still pass. If tests fail because the UPSERT dict now requires new keys, update the test seed helpers to include the new keys (set to None or 0).

Also verify the new methods exist: `python -c "from scraper.repository import MatchRepository, UPSERT_KILL_MATRIX, GET_PENDING_PERF_ECONOMY; print('Imports OK')"`

Verify get_valid_round_numbers: `python -c "from scraper.repository import MatchRepository; print('get_valid_round_numbers' in dir(MatchRepository)); print('Method exists')"`
  </verify>
  <done>UPSERT_PLAYER_STATS includes all 7 new columns. UPSERT_KILL_MATRIX and GET_PENDING_PERF_ECONOMY constants exist. Repository has get_pending_perf_economy(), get_valid_round_numbers(), and upsert_perf_economy_complete() methods. Phase 6 orchestrator dict includes opening_kills through round_swing. All existing tests pass.</done>
</task>

</tasks>

<verification>
1. `python -c "from scraper.db import Database; db = Database(':memory:'); db.initialize(); v = db.get_schema_version(); assert v == 4, f'Expected 4, got {v}'; print(f'Schema v{v} OK'); db.close()"`
2. `pytest tests/test_map_stats.py -v --tb=short` -- all tests pass (Phase 6 orchestrator still works)
3. `pytest tests/test_repository.py -v --tb=short` -- all existing repo tests pass
4. `python -c "from scraper.repository import UPSERT_KILL_MATRIX, GET_PENDING_PERF_ECONOMY; from scraper.config import ScraperConfig; c = ScraperConfig(); assert hasattr(c, 'perf_economy_batch_size'); print('All Phase 7 extensions verified')"`
</verification>

<success_criteria>
- Migration 004 adds 7 columns to player_stats and creates kill_matrix table
- UPSERT_PLAYER_STATS includes all new columns in INSERT, VALUES, and ON CONFLICT
- UPSERT_KILL_MATRIX constant exists with correct PK conflict target
- GET_PENDING_PERF_ECONOMY finds maps with player_stats but NULL kpr
- Repository has get_pending_perf_economy(), get_valid_round_numbers(), and upsert_perf_economy_complete() methods
- Phase 6 orchestrator dict maps opening_kills through round_swing from parser output
- ScraperConfig has perf_economy_batch_size field
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/07-performance-and-economy-extraction/07-01-SUMMARY.md`
</output>
