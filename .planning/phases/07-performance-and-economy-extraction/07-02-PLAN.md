---
phase: 07-performance-and-economy-extraction
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/scraper/performance_parser.py
  - tests/test_performance_parser.py
autonomous: true

must_haves:
  truths:
    - "Parser extracts KPR, DPR, KAST, ADR, and rating from all 10 player cards on a performance page"
    - "Parser detects Rating 2.0 (6 bars, Impact metric) vs Rating 3.0 (7 bars, MK rating + Swing) from FusionChart last bar label"
    - "Parser extracts 3 kill matrices (all, first_kill, awp) with correct player ID pairs and kill counts"
    - "Parser extracts team-level totals (kills, deaths, assists) from performance overview table"
    - "All 12 recon samples parse without errors"
  artifacts:
    - path: "src/scraper/performance_parser.py"
      provides: "Pure function performance page parser"
      exports: ["parse_performance", "PerformanceData", "PlayerPerformance", "KillMatrixEntry", "TeamOverview"]
      min_lines: 150
    - path: "tests/test_performance_parser.py"
      provides: "Parser tests against 12 real HTML samples"
      min_lines: 150
  key_links:
    - from: "src/scraper/performance_parser.py"
      to: "data/recon/performance-*.html.gz"
      via: "Parser logic derived from FusionChart JSON structure in recon samples"
      pattern: "data-fusionchart-config"
    - from: "src/scraper/performance_parser.py"
      to: "json.loads"
      via: "FusionChart JSON extraction using displayValue (not value)"
      pattern: "displayValue"
---

<objective>
Build a pure-function parser that extracts player performance metrics and kill matrix data from HLTV performance pages.

Purpose: The performance page contains per-player rate metrics (KPR, DPR, KAST, ADR, rating) embedded in FusionChart JSON, plus 3 kill matrices (all kills, first kills, AWP kills). This data fills the kpr/dpr/impact/mk_rating columns in player_stats and populates the kill_matrix table. The parser must handle both Rating 2.0 (6 bars, Impact metric) and Rating 3.0 (7 bars, MK rating + Swing).
Output: `src/scraper/performance_parser.py` (pure function) + comprehensive test suite against all 12 recon samples.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-performance-and-economy-extraction/07-RESEARCH.md
@.planning/phases/03-page-reconnaissance/recon/map-performance.md

# Pattern reference
@src/scraper/map_stats_parser.py
@tests/test_map_stats_parser.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Performance page parser implementation</name>
  <files>src/scraper/performance_parser.py</files>
  <action>
Create `src/scraper/performance_parser.py` following the established pure-function parser pattern from `map_stats_parser.py`.

**Dataclasses:**

```python
@dataclass
class PlayerPerformance:
    player_id: int
    player_name: str
    kpr: float
    dpr: float
    kast: float           # Percentage 0-100, stripped of '%'
    adr: float
    rating: float
    rating_version: str   # "2.0" or "3.0"
    mk_rating: float | None   # 3.0 only
    round_swing: float | None  # 3.0 only, signed percentage
    impact: float | None       # 2.0 only

@dataclass
class KillMatrixEntry:
    matrix_type: str      # "all", "first_kill", "awp"
    player1_id: int       # Row player (team2)
    player2_id: int       # Column player (team1)
    player1_kills: int    # Row player kills
    player2_kills: int    # Column player kills

@dataclass
class TeamOverview:
    team_name: str
    total_kills: int
    total_deaths: int
    total_assists: int

@dataclass
class PerformanceData:
    mapstatsid: int
    rating_version: str
    players: list[PlayerPerformance]
    kill_matrix: list[KillMatrixEntry]
    teams: list[TeamOverview]
```

**Main function:**
```python
def parse_performance(html: str, mapstatsid: int) -> PerformanceData:
```

**Implementation details:**

1. `_detect_rating_version(soup)`: Check first `[data-fusionchart-config]` element. Parse JSON, get `config['dataSource']['data']` (the bars array). If last bar's `label` == "Rating 3.0" -> "3.0". If "Rating 2.0" -> "2.0". Default "3.0".

2. `_parse_player_cards(soup, rating_version)`: Select all `.standard-box` elements that contain `[data-fusionchart-config]` (these are the 10 player cards). For each:
   - Player identity: `.headline a[href]` for player link, `.player-nick` for nickname
   - Player ID: `re.search(r'/player/(\d+)/', href)` from the headline link
   - FusionChart JSON: `json.loads(chart_el['data-fusionchart-config'])`
   - Build `bar_map = {bar['label']: bar['displayValue'] for bar in config['dataSource']['data']}`
   - CRITICAL: Use `displayValue`, NOT `value` (which is normalized chart height)
   - Common metrics: `float(bar_map['KPR'])`, `float(bar_map['DPR'])`, `float(bar_map['KAST'].rstrip('%'))`, `float(bar_map['ADR'])`
   - Rating 3.0 specific: `float(bar_map['Rating 3.0'])`, `float(bar_map['MK rating'])`, `float(bar_map['Swing'].rstrip('%'))`
   - Rating 2.0 specific: `float(bar_map['Rating 2.0'])`, `float(bar_map['Impact'])`
   - Handle KAST format: strip '%' suffix before float()
   - Handle Swing format: strip '%' suffix before float() (can be negative like "-1.20%")

3. `_parse_kill_matrix(soup)`: Parse all 3 kill matrix types. Select `.killmatrix-content` elements. Map IDs to types: `{"ALL-content": "all", "FIRST_KILL-content": "first_kill", "AWP-content": "awp"}`.
   - For each matrix container, select its `.stats-table`
   - Column headers: `.killmatrix-topbar td a` -- extract player IDs via `re.search(r'(?:/player/|/stats/players/)(\d+)/', href)` (TWO URL patterns exist)
   - Data rows: `tr:not(.killmatrix-topbar)` -- each row has a `td.team2` with player link (row player) and `td.text-center` cells with `.team2-player-score` and `.team1-player-score` spans
   - Return flat list of KillMatrixEntry

4. `_parse_team_overview(soup)`: Select `.overview-table` (or `.overview.standard-box table`). There are exactly 3 data rows (Kills, Deaths, Assists). Each row has 3 cells: stat name, team1 value, team2 value. Extract team names from table header row.
   - Return list of 2 TeamOverview

**Error handling:** Use `logger.warning()` for non-critical missing data (like a missing kill matrix). Raise `ValueError` for critical missing data (no player cards found, no FusionChart config).

**Imports:** `json`, `re`, `logging`, `dataclasses.dataclass`, `bs4.BeautifulSoup`.
  </action>
  <verify>
`python -c "from scraper.performance_parser import parse_performance, PerformanceData, PlayerPerformance, KillMatrixEntry, TeamOverview; print('Imports OK')"` succeeds.
  </verify>
  <done>Performance parser module exists with parse_performance() pure function, all 4 dataclasses, and internal helpers for rating detection, player card parsing, kill matrix parsing, and team overview parsing.</done>
</task>

<task type="auto">
  <name>Task 2: Performance parser test suite</name>
  <files>tests/test_performance_parser.py</files>
  <action>
Create `tests/test_performance_parser.py` following the pattern from `tests/test_map_stats_parser.py`.

**Test infrastructure:**
```python
RECON_DIR = Path(__file__).resolve().parent.parent / "data" / "recon"
ALL_SAMPLES = [
    ("performance-162345.html.gz", 162345),  # Rating 2.0
    ("performance-164779.html.gz", 164779),  # Rating 3.0
    ("performance-164780.html.gz", 164780),
    ("performance-173424.html.gz", 173424),
    ("performance-174112.html.gz", 174112),
    ("performance-174116.html.gz", 174116),
    ("performance-179210.html.gz", 179210),
    ("performance-188093.html.gz", 188093),
    ("performance-206389.html.gz", 206389),
    ("performance-206393.html.gz", 206393),
    ("performance-219128.html.gz", 219128),
    ("performance-219151.html.gz", 219151),
]
```

**Test classes:**

1. `TestPlayerMetricsExtraction` (fixture: sample 164779, Rating 3.0):
   - `test_ten_players_extracted` -- exactly 10 PlayerPerformance
   - `test_player_ids_non_zero` -- all player_id > 0
   - `test_kpr_range` -- all KPR in [0.0, 3.0] (reasonable range)
   - `test_dpr_range` -- all DPR in [0.0, 3.0]
   - `test_kast_range` -- all KAST in [0.0, 100.0]
   - `test_adr_range` -- all ADR in [0.0, 300.0]
   - `test_rating_range` -- all rating in [0.0, 3.0]
   - `test_player_names_non_empty` -- all names are non-empty strings

2. `TestRating20Handling` (fixture: sample 162345):
   - `test_rating_version_detected` -- `result.rating_version == "2.0"`
   - `test_impact_present` -- all players have `impact` as float (not None)
   - `test_mk_rating_absent` -- all players have `mk_rating is None`
   - `test_round_swing_absent` -- all players have `round_swing is None`
   - `test_six_bars_six_metrics` -- verify 6 metrics extracted (kpr, dpr, kast, impact, adr, rating)
   - `test_rating_label` -- rating value comes from "Rating 2.0" bar label

3. `TestRating30Handling` (fixture: sample 219128, most recent):
   - `test_rating_version_detected` -- `result.rating_version == "3.0"`
   - `test_mk_rating_present` -- all players have `mk_rating` as float (not None)
   - `test_round_swing_present` -- all players have `round_swing` as float (not None, can be negative)
   - `test_impact_absent` -- all players have `impact is None`
   - `test_rating_label` -- rating value comes from "Rating 3.0" bar label

4. `TestKillMatrixExtraction` (fixture: sample 164779):
   - `test_three_matrix_types` -- matrix entries include "all", "first_kill", "awp" types
   - `test_matrix_entry_count` -- 25 entries per type (5x5 grid), 75 total
   - `test_player_ids_non_zero` -- all player1_id and player2_id > 0
   - `test_kills_non_negative` -- all player1_kills >= 0 and player2_kills >= 0
   - `test_all_type_present` -- at least one entry with matrix_type == "all"

5. `TestTeamOverview` (fixture: sample 164779):
   - `test_two_teams` -- exactly 2 TeamOverview
   - `test_team_names_non_empty` -- both team names are non-empty
   - `test_kills_positive` -- both teams have total_kills > 0
   - `test_deaths_positive` -- both teams have total_deaths > 0

6. `TestAllSamplesParseWithoutCrash` -- parametrize across ALL_SAMPLES:
   - `test_parse_succeeds` -- `parse_performance(html, msid)` returns PerformanceData without exception
   - `test_has_players` -- `len(result.players) == 10`
   - `test_has_kill_matrix` -- `len(result.kill_matrix) > 0`

Use `@pytest.fixture(autouse=True)` with `setup` method in each class to load and parse sample once. Use `@pytest.mark.parametrize` for the smoke test class.
  </action>
  <verify>
`pytest tests/test_performance_parser.py -v --tb=short` -- all tests pass. No skipped tests (all 12 samples must be present in data/recon/).
  </verify>
  <done>Test suite covers Rating 2.0 and 3.0 handling, player metrics extraction, kill matrix parsing, team overview, and smoke tests across all 12 samples. All tests pass.</done>
</task>

</tasks>

<verification>
1. `pytest tests/test_performance_parser.py -v --tb=short` -- all tests pass
2. `python -c "import gzip; from pathlib import Path; from scraper.performance_parser import parse_performance; html = gzip.decompress(Path('data/recon/performance-164779.html.gz').read_bytes()).decode(); r = parse_performance(html, 164779); print(f'Players: {len(r.players)}, KM entries: {len(r.kill_matrix)}, Teams: {len(r.teams)}, Version: {r.rating_version}')"` -- outputs "Players: 10, KM entries: 75, Teams: 2, Version: 3.0"
3. `python -c "import gzip; from pathlib import Path; from scraper.performance_parser import parse_performance; html = gzip.decompress(Path('data/recon/performance-162345.html.gz').read_bytes()).decode(); r = parse_performance(html, 162345); print(f'Version: {r.rating_version}, Impact: {r.players[0].impact}, MK: {r.players[0].mk_rating}')"` -- outputs "Version: 2.0, Impact: <float>, MK: None"
</verification>

<success_criteria>
- parse_performance() extracts 10 players with valid KPR, DPR, KAST, ADR, rating
- Rating 2.0 detected correctly (sample 162345): Impact present, MK rating/Swing absent
- Rating 3.0 detected correctly (11 other samples): MK rating/Swing present, Impact absent
- 3 kill matrix types extracted with 25 entries each (75 total per map)
- Team overview extracts 2 teams with valid kill/death/assist totals
- All 12 recon samples parse without errors
- Uses displayValue (not value) from FusionChart JSON
</success_criteria>

<output>
After completion, create `.planning/phases/07-performance-and-economy-extraction/07-02-SUMMARY.md`
</output>
