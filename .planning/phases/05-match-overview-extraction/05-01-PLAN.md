---
phase: 05-match-overview-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - migrations/003_vetoes_rosters.sql
  - src/scraper/repository.py
  - src/scraper/discovery_repository.py
  - tests/test_repository.py
  - tests/test_discovery_repository.py
autonomous: true

must_haves:
  truths:
    - "Vetoes table exists with match_id + step_number composite PK and UPSERT support"
    - "Match_players table exists with match_id + player_id composite PK and UPSERT support"
    - "MatchRepository can atomically upsert a match with its maps, vetoes, and players in one transaction"
    - "DiscoveryRepository can retrieve pending matches and update their status to scraped or failed"
  artifacts:
    - path: "migrations/003_vetoes_rosters.sql"
      provides: "vetoes and match_players CREATE TABLE statements"
      contains: "CREATE TABLE IF NOT EXISTS vetoes"
    - path: "src/scraper/repository.py"
      provides: "UPSERT SQL and batch methods for vetoes and match_players"
      exports: ["UPSERT_VETO", "UPSERT_MATCH_PLAYER"]
    - path: "src/scraper/discovery_repository.py"
      provides: "Queue management methods for Phase 5 orchestrator"
      exports: ["get_pending_matches", "update_status"]
  key_links:
    - from: "migrations/003_vetoes_rosters.sql"
      to: "migrations/001_initial_schema.sql"
      via: "REFERENCES matches(match_id)"
      pattern: "REFERENCES matches"
    - from: "src/scraper/repository.py"
      to: "migrations/003_vetoes_rosters.sql"
      via: "UPSERT SQL matching table columns"
      pattern: "INSERT INTO vetoes|INSERT INTO match_players"
---

<objective>
Add database tables for vetoes and match rosters, plus repository methods needed by the match overview orchestrator.

Purpose: Phase 5 parser will extract veto sequences and player rosters, but the current schema has no tables for this data. The orchestrator also needs methods to pull pending matches from the scrape queue and update their status after processing.

Output: Migration 003 SQL file, extended MatchRepository with veto/player batch methods, extended DiscoveryRepository with queue management methods, and tests for all new functionality.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-match-overview-extraction/05-RESEARCH.md

@src/scraper/repository.py
@src/scraper/discovery_repository.py
@src/scraper/db.py
@migrations/001_initial_schema.sql
@migrations/002_scrape_queue.sql
@tests/test_repository.py
@tests/test_discovery_repository.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration 003 and add UPSERT SQL + repository methods</name>
  <files>
    migrations/003_vetoes_rosters.sql
    src/scraper/repository.py
    src/scraper/discovery_repository.py
  </files>
  <action>
**Migration file** (`migrations/003_vetoes_rosters.sql`):

Create two new tables:

```sql
CREATE TABLE IF NOT EXISTS vetoes (
    match_id     INTEGER NOT NULL REFERENCES matches(match_id),
    step_number  INTEGER NOT NULL,       -- 1-7
    team_name    TEXT,                   -- Team performing action (NULL for "left over")
    action       TEXT NOT NULL,          -- "removed", "picked", "left_over"
    map_name     TEXT NOT NULL,          -- Map being acted upon
    scraped_at   TEXT NOT NULL,
    updated_at   TEXT NOT NULL,
    source_url   TEXT,
    parser_version TEXT,
    PRIMARY KEY (match_id, step_number)
);

CREATE TABLE IF NOT EXISTS match_players (
    match_id     INTEGER NOT NULL REFERENCES matches(match_id),
    player_id    INTEGER NOT NULL,       -- HLTV player ID
    player_name  TEXT,                   -- Nickname at time of match
    team_id      INTEGER,               -- HLTV team ID
    team_num     INTEGER,               -- 1 or 2 (positional: team1 or team2)
    scraped_at   TEXT NOT NULL,
    updated_at   TEXT NOT NULL,
    source_url   TEXT,
    parser_version TEXT,
    PRIMARY KEY (match_id, player_id)
);
```

Add indexes: `idx_match_players_player` on `match_players(player_id)`, `idx_match_players_team` on `match_players(team_id)`.

**MatchRepository additions** (`src/scraper/repository.py`):

Add module-level SQL constants following the exact pattern of existing UPSERT constants:

- `UPSERT_VETO`: INSERT INTO vetoes with ON CONFLICT(match_id, step_number) DO UPDATE SET all non-PK columns. Use `:scraped_at` for both `scraped_at` and `updated_at` on insert, and `excluded.scraped_at` for `updated_at` on conflict (same pattern as UPSERT_MATCH).

- `UPSERT_MATCH_PLAYER`: INSERT INTO match_players with ON CONFLICT(match_id, player_id) DO UPDATE SET all non-PK columns. Same provenance pattern.

Add methods to MatchRepository:

- `upsert_match_overview(self, match_data: dict, maps_data: list[dict], vetoes_data: list[dict], players_data: list[dict]) -> None`: Atomically upsert a match with ALL its related data (match + maps + vetoes + players) in a single `with self.conn:` block. This is the primary method Phase 5 orchestrator will call. Loop through each list and execute the corresponding UPSERT.

- `get_vetoes(self, match_id: int) -> list[dict]`: Read method returning all vetoes for a match, ordered by step_number.

- `get_match_players(self, match_id: int) -> list[dict]`: Read method returning all players for a match, ordered by team_num then player_id.

**DiscoveryRepository additions** (`src/scraper/discovery_repository.py`):

Add module-level SQL constant:
- `UPDATE_STATUS = "UPDATE scrape_queue SET status = ? WHERE match_id = ?"`

Add methods:

- `get_pending_matches(self, limit: int = 10) -> list[dict]`: SELECT * FROM scrape_queue WHERE status = 'pending' ORDER BY match_id LIMIT ?. Return list of dict(row).

- `update_status(self, match_id: int, status: str) -> None`: Execute UPDATE_STATUS with `with self.conn:` for auto-commit. Status should be 'scraped' or 'failed'.
  </action>
  <verify>
Run `python -c "from scraper.repository import UPSERT_VETO, UPSERT_MATCH_PLAYER; print('OK')"` and `python -c "from scraper.discovery_repository import DiscoveryRepository; print('OK')"` -- both must print OK without import errors.
  </verify>
  <done>Migration 003 file exists. MatchRepository has upsert_match_overview, get_vetoes, get_match_players methods. DiscoveryRepository has get_pending_matches and update_status methods. All new SQL constants are defined at module level.</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for new repository methods</name>
  <files>
    tests/test_repository.py
    tests/test_discovery_repository.py
  </files>
  <action>
**Extend `tests/test_repository.py`**:

Add helper functions following the existing pattern (see `make_match_data`):

- `make_veto_data(match_id=1, step_number=1, **overrides)`: Returns dict with keys: match_id, step_number, team_name ("TeamA"), action ("removed"), map_name ("Nuke"), scraped_at (ISO timestamp), source_url, parser_version.

- `make_match_player_data(match_id=1, player_id=100, **overrides)`: Returns dict with keys: match_id, player_id, player_name ("player1"), team_id (4608), team_num (1), scraped_at, source_url, parser_version.

Add test class `TestUpsertMatchOverview`:

- `test_upsert_match_overview_inserts_all_data`: Create match_data + 3 maps + 7 vetoes + 10 players. Call `repo.upsert_match_overview(...)`. Assert match exists, 3 maps exist, 7 vetoes exist, 10 players exist using read methods.

- `test_upsert_match_overview_is_atomic`: Intentionally cause a failure mid-transaction (e.g., duplicate PK within the same batch with conflicting required fields). Verify either all data is written or none is.

- `test_upsert_match_overview_updates_on_conflict`: Insert data, then upsert again with modified fields (e.g., different player_name). Verify updated values and that updated_at changed.

Add test class `TestVetoes`:

- `test_get_vetoes_returns_ordered_steps`: Insert 7 vetoes out of order. Assert get_vetoes returns them ordered by step_number.

- `test_get_vetoes_empty_match`: Assert get_vetoes returns empty list for nonexistent match.

- `test_veto_with_null_team_name`: Insert a "left_over" veto with team_name=None. Assert it persists correctly.

Add test class `TestMatchPlayers`:

- `test_get_match_players_returns_ordered`: Insert 10 players across 2 teams. Assert get_match_players returns them ordered by team_num then player_id.

- `test_get_match_players_empty_match`: Assert returns empty list for nonexistent match.

**Extend `tests/test_discovery_repository.py`**:

Add test class `TestQueueManagement`:

- `test_get_pending_matches_returns_pending_only`: Insert 3 pending entries. Manually UPDATE one to 'scraped'. Call get_pending_matches(limit=10). Assert only 2 returned.

- `test_get_pending_matches_respects_limit`: Insert 5 pending entries. Call get_pending_matches(limit=2). Assert exactly 2 returned.

- `test_get_pending_matches_ordered_by_match_id`: Insert entries with match_ids [300, 100, 200]. Assert returned in order [100, 200, 300].

- `test_update_status_to_scraped`: Insert pending entry. Call update_status(match_id, 'scraped'). Verify status changed.

- `test_update_status_to_failed`: Insert pending entry. Call update_status(match_id, 'failed'). Verify status changed.

- `test_get_pending_matches_empty`: Assert returns empty list when no pending entries exist.

Follow existing fixture patterns exactly: `db` fixture using `Database(tmp_path / "test.db")` with `initialize()`, `repo` fixture wrapping `db.conn`.
  </action>
  <verify>
Run `pytest tests/test_repository.py tests/test_discovery_repository.py -v` -- all tests must pass (both existing and new).
  </verify>
  <done>All new repository and discovery_repository tests pass. Existing tests remain green. Migration 003 is applied by the test db fixture automatically via Database.initialize().</done>
</task>

</tasks>

<verification>
1. `pytest tests/test_repository.py tests/test_discovery_repository.py -v` -- all tests pass
2. `python -c "from scraper.repository import UPSERT_VETO, UPSERT_MATCH_PLAYER, MatchRepository; print('imports OK')"` -- no errors
3. `python -c "from scraper.discovery_repository import DiscoveryRepository; dr = None; print('OK')"` -- no errors
4. Migration file exists at `migrations/003_vetoes_rosters.sql` with correct SQL
</verification>

<success_criteria>
- Migration 003 creates vetoes and match_players tables with correct composite PKs and FK references
- MatchRepository.upsert_match_overview atomically writes match + maps + vetoes + players
- DiscoveryRepository.get_pending_matches returns pending queue entries with limit support
- DiscoveryRepository.update_status transitions entries to 'scraped' or 'failed'
- All tests pass including existing tests (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/05-match-overview-extraction/05-01-SUMMARY.md`
</output>
