---
phase: 05-match-overview-extraction
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/scraper/match_parser.py
  - tests/test_match_parser.py
autonomous: true

must_haves:
  truths:
    - "Parser extracts team names, IDs, scores, format, LAN flag, date, and event from any match overview page"
    - "Parser extracts the full veto sequence with team attribution and action type"
    - "Parser extracts per-map scores including CT/T half breakdowns for played maps"
    - "Parser extracts 10-player roster with player IDs and team assignment"
    - "Parser extracts mapstatsid links for all played, non-forfeit maps"
    - "Parser handles forfeits gracefully (partial data, no crash)"
    - "Parser handles unplayed maps (null scores, null mapstatsid, is_unplayed=True)"
    - "Parser handles overtime maps (regulation-only CT/T, total rounds include OT)"
  artifacts:
    - path: "src/scraper/match_parser.py"
      provides: "parse_match_overview pure function and dataclasses"
      exports: ["parse_match_overview", "MatchOverview", "MapResult", "VetoStep", "PlayerEntry"]
      min_lines: 150
    - path: "tests/test_match_parser.py"
      provides: "Unit tests against 9 real HTML samples"
      min_lines: 150
  key_links:
    - from: "src/scraper/match_parser.py"
      to: "data/recon/match-*-overview.html.gz"
      via: "CSS selectors verified in Phase 3 recon"
      pattern: "select_one|select"
    - from: "tests/test_match_parser.py"
      to: "data/recon/match-*-overview.html.gz"
      via: "load_sample helper loading gzipped HTML"
      pattern: "load_sample"
---

<objective>
Create a pure-function parser that extracts all match overview data from HLTV match pages, returning structured dataclasses. Test against 9 real HTML samples covering BO1, BO3, BO5, forfeit, partial forfeit, overtime, and unranked teams.

Purpose: This is the core extraction logic for Phase 5. The parser is stateless (HTML in, structured data out) following the exact pattern from Phase 4's parse_results_page. All downstream work (storage, persistence) depends on this parser producing correct output.

Output: `src/scraper/match_parser.py` with `parse_match_overview()` function and supporting dataclasses. `tests/test_match_parser.py` with comprehensive tests against real HTML samples.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-match-overview-extraction/05-RESEARCH.md

@src/scraper/discovery.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create match_parser.py with parse_match_overview function</name>
  <files>src/scraper/match_parser.py</files>
  <action>
Create `src/scraper/match_parser.py` following the Phase 4 parser pattern (pure function, dataclasses, BeautifulSoup + lxml).

**Dataclasses** (all use `from dataclasses import dataclass`):

```python
@dataclass
class VetoStep:
    step_number: int
    team_name: str | None   # None for "left over"
    action: str             # "removed", "picked", "left_over"
    map_name: str

@dataclass
class MapResult:
    map_number: int         # 1-based
    map_name: str
    mapstatsid: int | None  # None for forfeit/unplayed maps
    team1_rounds: int | None
    team2_rounds: int | None
    team1_ct_rounds: int | None  # Regulation-only CT rounds
    team1_t_rounds: int | None   # Regulation-only T rounds
    team2_ct_rounds: int | None
    team2_t_rounds: int | None
    is_unplayed: bool
    is_forfeit_map: bool

@dataclass
class PlayerEntry:
    player_id: int
    player_name: str | None
    team_id: int | None
    team_num: int           # 1 or 2

@dataclass
class MatchOverview:
    match_id: int
    team1_name: str
    team2_name: str
    team1_id: int
    team2_id: int
    team1_score: int | None   # Raw .won/.lost value (maps won for BO3/BO5, round score for BO1). None on full forfeit.
    team2_score: int | None
    best_of: int              # 1, 3, or 5
    is_lan: int               # 0 or 1
    date_unix_ms: int
    event_id: int
    event_name: str
    maps: list[MapResult]
    vetoes: list[VetoStep] | None   # None if unparseable or missing
    players: list[PlayerEntry]
    is_forfeit: bool          # True if any map has map_name == "Default"
```

**Main function signature:**
```python
def parse_match_overview(html: str, match_id: int) -> MatchOverview:
```

**Implementation details (use internal helper functions):**

**_extract_match_metadata(soup, match_id) -> dict:**
- Team names: `.team1-gradient .teamName` and `.team2-gradient .teamName` text
- Team IDs: Extract from `.team1-gradient a[href*="/team/"]` href using regex `/team/(\d+)/`
- Scores: Check for `.team1-gradient .won` first, then `.team1-gradient .lost`. If both None (full forfeit), set score to None. Same for team2. Store raw values as-is (for BO1 this is round score, for BO3/BO5 this is maps won -- the `best_of` column distinguishes semantics).
- Date: `.timeAndEvent .date[data-unix]` attribute -> int
- Event: `.timeAndEvent .event a[href*="/events/"]` text and href (regex `/events/(\d+)/`)
- Format: `.padding.preformatted-text` text, regex `Best of (\d+)`. If no match, default best_of=1.
- LAN: From same format text, regex `\((LAN|Online)\)`. Default to 0 (online) if not found (per CONTEXT.md decision).

**_extract_maps(soup) -> list[MapResult]:**
- Iterate `.mapholder` elements (enumerate from 1)
- Map name: `.mapname` text
- Unplayed detection: `.optional` class present on mapholder
- Forfeit map detection: map_name == "Default"
- Scores: `.results-left .results-team-score` and `.results-right .results-team-score` text -> int. None for unplayed/forfeit.
- MapStatsID: `a.results-stats[href]` -> regex `/mapstatsid/(\d+)/`. None if not found.
- Half scores: Only for played, non-forfeit maps. Call `_parse_half_scores()`.

**_parse_half_scores(hs_el) -> dict:**
- Select all `span` children
- Extract numeric values paired with CSS class ('ct', 't', or None for OT)
- First 4 values with ct/t classes are regulation halves
- Layout: positions 0,1 = half1 (team1_half1, team2_half1), positions 2,3 = half2 (team1_half2, team2_half2)
- If position 0 has class 'ct': team1 started CT -> team1_ct = pos0 value, team1_t = pos2 value, team2_t = pos1 value, team2_ct = pos3 value
- If position 0 has class 't': team1 started T -> team1_t = pos0 value, team1_ct = pos2 value, team2_ct = pos1 value, team2_t = pos3 value
- Overtime values (positions 4+): have no ct/t class. DO NOT add to ct/t columns -- regulation-only. The total rounds from the map score include OT already.
- Return dict with team1_ct, team1_t, team2_ct, team2_t (regulation only)

**_extract_vetoes(soup) -> list[VetoStep] | None:**
- Select `.veto-box` elements. MUST use index [1] for actual vetoes (index [0] is format/stage info).
- If fewer than 2 veto boxes, return None.
- Select `.padding > div` within the second veto box for veto lines.
- Parse each line text with regex patterns:
  - `(\d+)\. (.+) removed (.+)` -> action="removed"
  - `(\d+)\. (.+) picked (.+)` -> action="picked"
  - `(\d+)\. (.+) was left over` -> action="left_over", team_name=None
- Return list of VetoStep, or None if no lines parsed.

**_extract_rosters(soup) -> list[PlayerEntry]:**
- Select `.lineups .lineup.standard-box` elements
- For each lineup (enumerate from 1 for team_num):
  - Team ID: `.box-headline a.text-ellipsis` href -> regex `/team/(\d+)/`
  - Players: Select `[data-player-id]` elements within lineup
  - For each player: player_id from `data-player-id` attribute (int), player_name from `.text-ellipsis` child text
- Return list of PlayerEntry

**Forfeit detection:**
- After extracting maps, set `is_forfeit = any(m.map_name == "Default" for m in maps)`

**Error handling:**
- Use `logging.getLogger(__name__)` for warnings on unexpected structures
- If a CSS selector returns None for a REQUIRED field (team names, team IDs, date, event), log error and raise ValueError with descriptive message
- If an OPTIONAL field is missing (vetoes, half scores, LAN flag), use None/default and log warning
  </action>
  <verify>
Run `python -c "from scraper.match_parser import parse_match_overview, MatchOverview, MapResult, VetoStep, PlayerEntry; print('OK')"` -- must print OK.
  </verify>
  <done>match_parser.py exports parse_match_overview function and all 4 dataclasses. Function accepts HTML string + match_id, returns MatchOverview with all fields populated from CSS selectors verified in Phase 3 recon.</done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive tests against real HTML samples</name>
  <files>tests/test_match_parser.py</files>
  <action>
Create `tests/test_match_parser.py` following the Phase 4 test pattern (load gzipped HTML samples from `data/recon/`, parse, assert on fields).

**Setup:**
```python
import gzip
from pathlib import Path
import pytest
from scraper.match_parser import parse_match_overview, MatchOverview, MapResult, VetoStep, PlayerEntry

RECON_DIR = Path(__file__).resolve().parent.parent / "data" / "recon"

def load_sample(filename: str) -> str:
    path = RECON_DIR / filename
    if not path.exists():
        pytest.skip(f"Sample HTML not found: {path}")
    return gzip.decompress(path.read_bytes()).decode("utf-8")
```

**Available samples and their characteristics** (from RESEARCH.md):
- `match-2389951-overview.html.gz` -- Vitality vs G2, BO3, tier-1 LAN, normal match
- `match-2380434-overview.html.gz` -- Full forfeit match
- `match-2384993-overview.html.gz` -- BO5, partial forfeit + overtime
- `match-2366498-overview.html.gz` -- BO1, overtime, unranked teams
- `match-2367432-overview.html.gz`, `match-2371389-overview.html.gz`, `match-2377467-overview.html.gz`, `match-2371321-overview.html.gz`, `match-2373741-overview.html.gz` -- Additional samples

**Test classes:**

**TestMatchMetadata** -- test against BO3 LAN sample (2389951):
- `test_team_names_extracted`: Assert team1_name and team2_name are non-empty strings
- `test_team_ids_are_positive_integers`: Assert team1_id and team2_id > 0
- `test_scores_are_integers`: Assert team1_score and team2_score are int (not None)
- `test_best_of_is_valid`: Assert best_of in (1, 3, 5)
- `test_is_lan_is_binary`: Assert is_lan in (0, 1)
- `test_date_unix_ms_is_13_digits`: Assert len(str(date_unix_ms)) == 13
- `test_event_extracted`: Assert event_id > 0 and event_name is non-empty string
- `test_match_id_matches_input`: Assert result.match_id == 2389951

**TestBO1Match** -- test against BO1 sample (2366498):
- `test_best_of_is_1`: Assert best_of == 1
- `test_single_map_extracted`: Assert len(maps) == 1
- `test_scores_are_round_scores`: Assert team1_score and team2_score are > 10 (round scores, not maps-won counts)
- `test_map_has_mapstatsid`: Assert maps[0].mapstatsid is not None

**TestBO5Match** -- test against BO5 sample (2384993):
- `test_best_of_is_5`: Assert best_of == 5
- `test_five_maps_extracted`: Assert len(maps) == 5
- `test_has_unplayed_maps`: Assert any(m.is_unplayed for m in maps) -- BO5 often has unplayed maps

**TestForfeitMatch** -- test against full forfeit (2380434):
- `test_is_forfeit_true`: Assert is_forfeit == True
- `test_scores_are_none_or_zero`: Assert team1_score is None or team2_score is None (full forfeit may lack score divs)
- `test_forfeit_map_detected`: Assert any(m.is_forfeit_map for m in maps)
- `test_no_mapstatsids_on_forfeit`: Assert all mapstatsid is None for forfeit maps
- `test_players_still_extracted`: Assert len(players) == 10 (rosters exist even on forfeits)

**TestMapExtraction** -- test against BO3 sample (2389951):
- `test_correct_map_count`: Assert len(maps) == 3 for a BO3
- `test_map_names_are_strings`: Assert all map_name is non-empty string
- `test_played_maps_have_scores`: For non-unplayed maps, assert team1_rounds and team2_rounds are ints
- `test_played_maps_have_mapstatsid`: For non-unplayed, non-forfeit maps, assert mapstatsid is not None and > 0
- `test_map_numbers_sequential`: Assert map_number values are [1, 2, 3]

**TestUnplayedMaps** -- test against a BO3/BO5 sample with unplayed maps:
- `test_unplayed_map_has_null_scores`: Assert team1_rounds is None and team2_rounds is None
- `test_unplayed_map_has_null_mapstatsid`: Assert mapstatsid is None
- `test_unplayed_map_flagged`: Assert is_unplayed == True

**TestHalfScores** -- test against normal BO3 sample (2389951):
- `test_played_maps_have_half_scores`: For played maps, assert team1_ct_rounds and team1_t_rounds and team2_ct_rounds and team2_t_rounds are not None
- `test_half_scores_sum_to_regulation`: For non-OT maps, assert team1_ct + team1_t + team2_ct + team2_t equals total rounds (team1_rounds + team2_rounds), OR for OT maps, assert ct+t sum <= total rounds (because ct/t are regulation-only)
- `test_ct_t_values_are_reasonable`: Assert all half-score values are >= 0 and <= 13 (max regulation half is 13)

**TestOvertimeHalfScores** -- test against overtime sample (2366498 or 2384993):
- `test_regulation_halves_present`: Assert ct and t round values exist
- `test_total_rounds_exceed_regulation`: Assert team1_rounds + team2_rounds > 24 (OT means > 24 total)
- `test_ct_t_are_regulation_only`: Assert team1_ct + team1_t <= 12 or similar regulation constraint (max 13 per half)

**TestVetoExtraction** -- test against BO3 sample (2389951):
- `test_vetoes_extracted`: Assert vetoes is not None
- `test_veto_steps_sequential`: Assert step_numbers are sequential starting from 1
- `test_veto_actions_valid`: Assert all actions in ("removed", "picked", "left_over")
- `test_veto_team_names_not_empty`: For non-left_over steps, assert team_name is not None and non-empty
- `test_left_over_has_null_team`: For left_over steps, assert team_name is None
- `test_veto_map_names_valid`: Assert all map_name values are non-empty strings

**TestRosterExtraction** -- test against BO3 sample (2389951):
- `test_ten_players_extracted`: Assert len(players) == 10
- `test_five_per_team`: Assert 5 players with team_num==1 and 5 with team_num==2
- `test_player_ids_positive`: Assert all player_id > 0
- `test_player_names_not_empty`: Assert all player_name is non-empty string
- `test_team_ids_match_match_teams`: Assert player team_ids match match team1_id or team2_id

**TestAllSamplesParseWithoutCrash** -- smoke test across ALL 9 samples:
- `test_all_samples_parse`: Parametrize across all 9 sample filenames. For each, load and call parse_match_overview. Assert no exception raised and result is MatchOverview instance.
  </action>
  <verify>
Run `pytest tests/test_match_parser.py -v` -- all tests must pass. Expected: 30+ tests across the test classes.
  </verify>
  <done>All parser tests pass against 9 real HTML samples. Tests cover BO1, BO3, BO5, forfeit, overtime, unplayed maps, half scores, vetoes, and rosters. Every sample parses without crash.</done>
</task>

</tasks>

<verification>
1. `pytest tests/test_match_parser.py -v` -- all tests pass
2. `python -c "from scraper.match_parser import parse_match_overview; print('OK')"` -- no import errors
3. Parser handles all 9 HTML samples without crashing
4. Forfeit sample returns is_forfeit=True with partial data
5. BO1 sample returns best_of=1 with correct round scores
</verification>

<success_criteria>
- parse_match_overview(html, match_id) returns MatchOverview with all fields populated from CSS selectors
- Parser handles all edge cases: forfeit, BO1, BO5, overtime, unplayed maps, unranked teams
- Half scores are regulation-only (OT rounds not added to CT/T columns)
- Vetoes correctly parsed from second .veto-box with team attribution
- 10 players extracted with correct team assignment
- All 9 recon samples parse without crash
- 30+ tests pass covering every extraction concern
</success_criteria>

<output>
After completion, create `.planning/phases/05-match-overview-extraction/05-02-SUMMARY.md`
</output>
