---
phase: 06-map-stats-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/scraper/map_stats_parser.py
  - tests/test_map_stats_parser.py
autonomous: true

must_haves:
  truths:
    - "Parser extracts per-player scoreboard with kills, deaths, assists, flash assists, HS kills, ADR, KAST, rating, Op.K-D, multi-kills, clutch wins from each map stats page"
    - "Parser extracts round-by-round history with winner team, winner side, and win type for every round including overtime"
    - "Parser detects Rating 2.0 vs 3.0 and stores the rating value in the correct field"
    - "Parser handles all 3 overtime patterns: no OT, single OT (30 rounds, 1 container), extended OT (36+ rounds, 2 containers)"
    - "Parser extracts CT/T half breakdown and team starting side"
  artifacts:
    - path: "src/scraper/map_stats_parser.py"
      provides: "Pure function parse_map_stats(html, mapstatsid) -> MapStats"
      exports: ["parse_map_stats", "MapStats", "PlayerStats", "RoundOutcome"]
    - path: "tests/test_map_stats_parser.py"
      provides: "Tests against 12 real HTML samples covering all edge cases"
      min_lines: 150
  key_links:
    - from: "src/scraper/map_stats_parser.py"
      to: "data/recon/mapstats-*-stats.html.gz"
      via: "CSS selectors verified in Phase 3 recon"
      pattern: "select.*totalstats|select.*round-history"
---

<objective>
Create a pure-function parser that extracts per-player scoreboards and round-by-round history from HLTV map stats pages.

Purpose: This is the core extraction logic for Phase 6. The parser converts raw HTML into structured dataclasses that the orchestrator (Plan 06-03) will persist to the database. It must handle Rating 2.0/3.0 differences, all overtime patterns, and compound field formats.

Output: `src/scraper/map_stats_parser.py` with full test coverage against 12 recon samples.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-map-stats-extraction/06-RESEARCH.md

Key references (read these during execution):
- src/scraper/match_parser.py -- Follow this exact pattern (pure function, dataclasses, BeautifulSoup, _extract_* helpers)
- tests/test_match_parser.py -- Follow this exact test pattern (load_sample helper, class-per-concern, parametrized smoke test)
- .planning/phases/03-page-reconnaissance/recon/map-stats.md -- 872-line selector map with verified CSS selectors
- .planning/phases/03-page-reconnaissance/recon/edge-cases.md -- OT patterns, Rating 2.0 differences
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create map_stats_parser.py with dataclasses and pure function parser</name>
  <files>src/scraper/map_stats_parser.py</files>
  <action>
Create `src/scraper/map_stats_parser.py` following the exact pattern of `match_parser.py`:

**Dataclasses (3 total):**

1. `PlayerStats` with fields:
   - player_id: int, player_name: str, team_id: int
   - kills: int, deaths: int, assists: int, flash_assists: int, hs_kills: int
   - kd_diff: int (computed: kills - deaths)
   - adr: float, kast: float
   - opening_kills: int, opening_deaths: int, fk_diff: int (computed: opening_kills - opening_deaths)
   - rating: float, rating_version: str ("2.0" or "3.0")
   - multi_kills: int, clutch_wins: int, traded_deaths: int
   - round_swing: float | None (Rating 3.0 only, None for 2.0)

2. `RoundOutcome` with fields:
   - round_number: int, winner_team_id: int, winner_side: str ("CT" or "T"), win_type: str ("elimination", "bomb_planted", "defuse", "time")

3. `MapStats` with fields:
   - mapstatsid: int
   - team_left_id: int, team_left_name: str, team_right_id: int, team_right_name: str
   - team_left_score: int, team_right_score: int
   - map_name: str, rating_version: str
   - team_left_ct_rounds: int, team_left_t_rounds: int, team_right_ct_rounds: int, team_right_t_rounds: int
   - team_left_starting_side: str ("CT" or "T")
   - players: list[PlayerStats]
   - rounds: list[RoundOutcome]

**Main function:**
```python
def parse_map_stats(html: str, mapstatsid: int) -> MapStats:
```
Pure function: HTML string in, MapStats out. No side effects. Raises ValueError for missing required elements.

**Internal helpers (prefix with _):**

`_detect_rating_version(soup)` -> str:
- Check `th.st-rating` text for "3.0" or "2.0"
- Fallback: presence of `th.st-roundSwing` -> "3.0"
- Default: "3.0" (modern pages)

`_extract_metadata(soup, mapstatsid)` -> dict:
- Map name: bare NavigableString child of `.match-info-box` (no CSS class on the text node itself -- iterate children, find first non-empty NavigableString)
- Team left: `.team-left a` text and href regex `/stats/teams/(\d+)/`
- Team right: `.team-right a` text and href regex `/stats/teams/(\d+)/`
- Scores: `.team-left .bold` and `.team-right .bold` text -> int

`_extract_half_breakdown(soup)` -> dict:
- Find spans with `ct-color` and `t-color` classes inside the score breakdown area
- First 4 side-valued spans are regulation halves: [0]=team_left half1, [1]=team_right half1, [2]=team_left half2, [3]=team_right half2
- side_values[0].side tells team_left's starting side
- Return team_left_ct_rounds, team_left_t_rounds, team_right_ct_rounds, team_right_t_rounds, team_left_starting_side

`_extract_scoreboard(soup, rating_version, team_left_id, team_right_id)` -> list[PlayerStats]:
- Select `.stats-table.totalstats` tables. First = team-left, second = team-right.
- For each `tbody tr` in each table, extract:
  - player_id from `td.st-player a[href]` regex `/stats/players/(\d+)/`
  - player_name from `td.st-player a` text
  - kills/hs_kills from `td.st-kills.traditional-data` text "14(9)" regex `(\d+)\((\d+)\)`
  - assists/flash_assists from `td.st-assists` text "2(0)" regex `(\d+)\((\d+)\)`
  - deaths/traded_deaths from `td.st-deaths.traditional-data` text "15(2)" regex `(\d+)\((\d+)\)`
  - adr from `td.st-adr.traditional-data` text -> float
  - kast from `td.st-kast.gtSmartphone-only.traditional-data` text "66.7%" -> float (strip %)
  - rating from `td.st-rating` text -> float
  - Op.K-D from `td.st-opkd.gtSmartphone-only.traditional-data` text "2 : 5" regex `(\d+)\s*:\s*(\d+)`
  - multi_kills from `td.st-mks.gtSmartphone-only` text -> int
  - clutch_wins from `td.st-clutches.gtSmartphone-only` text -> int
  - round_swing (Rating 3.0 only): `td.st-roundSwing` text "+2.90%" -> float (strip %)
  - kd_diff = kills - deaths
  - fk_diff = opening_kills - opening_deaths
  - team_id = team_left_id for first table, team_right_id for second table

  IMPORTANT for Rating 2.0 (sample 162345): No `st-roundSwing` column, no `st-mks`, no `st-clutches`, no `st-opkd`. When these selectors return None, set the corresponding values to 0 or None as appropriate. The st-kast selector may also differ. Handle gracefully with fallback defaults.

  Actually, re-read the recon map-stats.md carefully during implementation. Rating 2.0 pages DO have Op.K-D, multi-kills, and clutches in the TRADITIONAL data columns. The difference is: no st-roundSwing column, and the rating column header says "Rating 2.0" instead of "Rating 3.0". All other traditional-data columns are present in both versions. The eco-adjusted columns (which we are NOT extracting) are the ones that show "null" on Rating 2.0 pages.

`_extract_round_history(soup, team_left_id, team_right_id)` -> list[RoundOutcome]:
- Outcome image to (winner_side, win_type) mapping:
  - ct_win.svg -> ("CT", "elimination")
  - t_win.svg -> ("T", "elimination")
  - bomb_exploded.svg -> ("T", "bomb_planted")
  - bomb_defused.svg -> ("CT", "defuse")
  - stopwatch.svg -> ("CT", "time")
- Select `.round-history-con` containers (1 or 2)
- For each container, get `.round-history-team-row` elements (2 per container: top=team-left, bottom=team-right)
- For each pair of team rows, iterate `img.round-history-outcome` elements in parallel (zip)
- For each round: check which team row has a non-empty outcome (not containing "emptyHistory" in src)
- Determine winner_team_id from which row has the non-empty outcome
- Look up (winner_side, win_type) from OUTCOME_MAP using the filename from the src attribute
- Increment round_number starting from 1, continuing across containers
- Skip any img elements where BOTH sides show emptyHistory (should not happen but defensive)

**Logging:** Use `logging.getLogger(__name__)` with warnings for missing optional elements. Raise ValueError for missing required elements (team names, team IDs, scores).
  </action>
  <verify>
Run `python -c "from scraper.map_stats_parser import parse_map_stats, MapStats, PlayerStats, RoundOutcome; print('imports OK')"` to confirm the module imports cleanly with no syntax errors.
  </verify>
  <done>
Module exists at src/scraper/map_stats_parser.py with parse_map_stats pure function, 3 dataclasses, and 5+ internal _extract helpers. All CSS selectors match the Phase 3 recon selector map.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive tests against all 12 recon samples</name>
  <files>tests/test_map_stats_parser.py</files>
  <action>
Create `tests/test_map_stats_parser.py` following the exact pattern of `test_match_parser.py`:

**Setup:**
```python
RECON_DIR = Path(__file__).resolve().parent.parent / "data" / "recon"
```

**load_sample helper:** Same pattern as test_match_parser.py -- gzip decompress, pytest.skip if not found.

**ALL_SAMPLES list:** All 12 mapstats samples with their mapstatsid values:
```python
ALL_SAMPLES = [
    ("mapstats-162345-stats.html.gz", 162345),  # Rating 2.0, single OT (30 rounds)
    ("mapstats-164779-stats.html.gz", 164779),  # Rating 3.0, standard
    ("mapstats-164780-stats.html.gz", 164780),
    ("mapstats-173424-stats.html.gz", 173424),
    ("mapstats-174112-stats.html.gz", 174112),
    ("mapstats-174116-stats.html.gz", 174116),
    ("mapstats-179210-stats.html.gz", 179210),
    ("mapstats-188093-stats.html.gz", 188093),
    ("mapstats-206389-stats.html.gz", 206389),  # Extended OT (36 rounds, 2 containers)
    ("mapstats-206393-stats.html.gz", 206393),
    ("mapstats-219128-stats.html.gz", 219128),
    ("mapstats-219151-stats.html.gz", 219151),
]
```

**Test classes (one per concern):**

1. `TestScoreboardExtraction` (use sample 164779, standard Rating 3.0):
   - test_ten_players_extracted: len(result.players) == 10
   - test_five_per_team: 5 players with team_left_id, 5 with team_right_id
   - test_player_ids_positive: all player_id > 0
   - test_player_names_not_empty: all player_name is non-empty string
   - test_kills_deaths_assists_are_nonnegative: kills >= 0, deaths >= 0, assists >= 0
   - test_hs_kills_lte_kills: hs_kills <= kills for all players
   - test_adr_is_positive: 0 < adr < 200 for all players
   - test_kast_is_percentage: 0 <= kast <= 100 for all players
   - test_rating_is_reasonable: 0.0 < rating < 3.0 for all players
   - test_kd_diff_computed_correctly: kd_diff == kills - deaths for all players
   - test_fk_diff_computed_correctly: fk_diff == opening_kills - opening_deaths for all players

2. `TestRating20Handling` (use sample 162345, Rating 2.0):
   - test_rating_version_detected: result.rating_version == "2.0"
   - test_player_rating_version: all players have rating_version == "2.0"
   - test_round_swing_is_none: all players have round_swing is None
   - test_scoreboard_extracted_completely: 10 players with real stats (kills > 0 for at least some)
   - test_rating_value_reasonable: 0.0 < rating < 3.0

3. `TestRating30Handling` (use sample 219128, modern Rating 3.0):
   - test_rating_version_detected: result.rating_version == "3.0"
   - test_player_rating_version: all players have rating_version == "3.0"
   - test_round_swing_extracted: at least some players have round_swing is not None

4. `TestRoundHistoryStandard` (use sample 164779, standard match):
   - test_rounds_extracted: len(result.rounds) > 0
   - test_round_numbers_sequential: round numbers are 1, 2, 3, ..., N
   - test_round_count_matches_score: len(result.rounds) == team_left_score + team_right_score
   - test_winner_sides_valid: all winner_side in ("CT", "T")
   - test_win_types_valid: all win_type in ("elimination", "bomb_planted", "defuse", "time")
   - test_winner_team_ids_valid: all winner_team_id in (result.team_left_id, result.team_right_id)

5. `TestSingleOvertimeRounds` (use sample 162345, 30 rounds):
   - test_round_count_exceeds_24: len(result.rounds) > 24
   - test_round_count_matches_score: len(result.rounds) == team_left_score + team_right_score
   - test_rounds_sequential_through_ot: round numbers continuous from 1 to total

6. `TestExtendedOvertimeRounds` (use sample 206389, 36 rounds, 2 containers):
   - test_round_count_exceeds_30: len(result.rounds) > 30
   - test_round_count_matches_score: len(result.rounds) == team_left_score + team_right_score
   - test_rounds_sequential_through_extended_ot: round numbers continuous from 1 to total

7. `TestMapMetadata` (use sample 164779):
   - test_map_name_extracted: result.map_name is a non-empty string (one of known CS2 maps)
   - test_team_names_extracted: both team names are non-empty strings
   - test_team_ids_positive: both team IDs > 0
   - test_scores_are_nonneg_integers: both scores >= 0
   - test_mapstatsid_matches: result.mapstatsid == 164779

8. `TestHalfBreakdown` (use sample 164779):
   - test_half_values_nonnegative: all ct/t round values >= 0
   - test_starting_side_valid: team_left_starting_side in ("CT", "T")
   - test_halves_sum_to_regulation: team_left_ct + team_left_t + team_right_ct + team_right_t == min(total_score, 24)

9. `TestAllSamplesParseWithoutCrash` (parametrized across ALL_SAMPLES):
   - test_all_samples_parse: parse succeeds, result is MapStats, has 10 players, has rounds, teams extracted

Run: `pytest tests/test_map_stats_parser.py -v`

All tests must pass. Debug any failures by reading the recon selector map and adjusting extraction logic in the parser.
  </action>
  <verify>
`pytest tests/test_map_stats_parser.py -v` -- all tests pass, 0 failures, 0 errors.
  </verify>
  <done>
All 12 recon samples parse successfully. Tests verify: scoreboard extraction (10 players, correct stats), Rating 2.0 handling (162345), Rating 3.0 handling (219128), round history for standard/single OT/extended OT, map metadata, half breakdown. Zero test failures.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from scraper.map_stats_parser import parse_map_stats, MapStats, PlayerStats, RoundOutcome"` succeeds
2. `pytest tests/test_map_stats_parser.py -v` -- all tests pass
3. Parser handles Rating 2.0 sample (162345) without errors
4. Parser handles extended OT sample (206389) with correct round count
5. All 12 samples parse without exceptions (parametrized test)
</verification>

<success_criteria>
- parse_map_stats(html, mapstatsid) returns MapStats with 10 players, correct round count, correct rating version for all 12 samples
- Rating 2.0 (162345): rating_version="2.0", round_swing=None, rounds > 24
- Extended OT (206389): rounds > 30, sequential round numbers
- All player stats have non-negative values, kd_diff and fk_diff computed correctly
- Zero test failures across the full test suite
</success_criteria>

<output>
After completion, create `.planning/phases/06-map-stats-extraction/06-01-SUMMARY.md`
</output>
