---
phase: 06-map-stats-extraction
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/scraper/repository.py
  - src/scraper/config.py
  - tests/test_repository.py
autonomous: true

must_haves:
  truths:
    - "Repository can query maps that have a mapstatsid but no player_stats rows yet"
    - "Repository can atomically persist player_stats and round_history for a single map in one transaction"
    - "Config has a map_stats_batch_size setting for controlling orchestrator batch sizes"
  artifacts:
    - path: "src/scraper/repository.py"
      provides: "get_pending_map_stats() and upsert_map_stats_complete() methods"
      contains: "get_pending_map_stats"
    - path: "src/scraper/config.py"
      provides: "map_stats_batch_size config field"
      contains: "map_stats_batch_size"
    - path: "tests/test_repository.py"
      provides: "Tests for new repository methods"
      contains: "test_get_pending_map_stats"
  key_links:
    - from: "src/scraper/repository.py"
      to: "maps table + player_stats table"
      via: "NOT EXISTS subquery"
      pattern: "NOT EXISTS.*player_stats"
---

<objective>
Extend the repository with a query to find unprocessed maps and a convenience method to atomically persist all map stats data, plus add batch size config.

Purpose: The Phase 6 orchestrator (Plan 06-03) needs to know which maps still need processing and needs an atomic write method. This plan provides both without modifying the parser or orchestrator code.

Output: Extended `repository.py` with 2 new methods, extended `config.py` with 1 new field, tests for new methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-map-stats-extraction/06-RESEARCH.md

Key references (read these during execution):
- src/scraper/repository.py -- Existing repository pattern to extend
- src/scraper/config.py -- Existing config to extend
- tests/test_repository.py -- Existing tests to extend
- migrations/001_initial_schema.sql -- DB schema for player_stats, round_history, maps tables
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add get_pending_map_stats and upsert_map_stats_complete to repository</name>
  <files>src/scraper/repository.py, src/scraper/config.py</files>
  <action>
**1. Extend src/scraper/config.py:**

Add one new field to `ScraperConfig`:
```python
# Map stats batch size (maps per batch, not matches)
map_stats_batch_size: int = 10
```

**2. Add SQL constant to src/scraper/repository.py** (after existing SQL constants):

```python
GET_PENDING_MAP_STATS = """
    SELECT m.match_id, m.map_number, m.mapstatsid
    FROM maps m
    WHERE m.mapstatsid IS NOT NULL
      AND NOT EXISTS (
        SELECT 1 FROM player_stats ps
        WHERE ps.match_id = m.match_id AND ps.map_number = m.map_number
      )
    ORDER BY m.match_id, m.map_number
    LIMIT ?
"""
```

**3. Add two methods to MatchRepository class:**

`get_pending_map_stats(self, limit: int = 10) -> list[dict]`:
- Execute GET_PENDING_MAP_STATS with limit parameter
- Return list of dicts with keys: match_id, map_number, mapstatsid
- Return empty list if no pending maps
- This is a READ method (no `with self.conn:` needed)

`upsert_map_stats_complete(self, stats_data: list[dict], rounds_data: list[dict]) -> None`:
- Atomically upsert player_stats AND round_history in a single transaction
- Uses `with self.conn:` for atomicity
- Iterates stats_data calling `self.conn.execute(UPSERT_PLAYER_STATS, row)`
- Iterates rounds_data calling `self.conn.execute(UPSERT_ROUND, row)`
- This ensures either ALL data for a map is written or NONE of it is (rollback on error)

Place the new methods logically:
- `get_pending_map_stats` goes in the "Read methods" section
- `upsert_map_stats_complete` goes in the "Batch UPSERT methods" section

Do NOT modify any existing methods. Only add new ones.
  </action>
  <verify>
Run `python -c "from scraper.repository import MatchRepository; from scraper.config import ScraperConfig; c = ScraperConfig(); print(f'batch_size={c.map_stats_batch_size}')"` to confirm imports and config field.
  </verify>
  <done>
repository.py has get_pending_map_stats() and upsert_map_stats_complete() methods. config.py has map_stats_batch_size field with default 10.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for new repository methods</name>
  <files>tests/test_repository.py</files>
  <action>
Read `tests/test_repository.py` first to understand the existing test structure and fixtures.

Add new test classes to `tests/test_repository.py` (append, do not modify existing tests):

**TestGetPendingMapStats:**

Setup: Use existing DB fixtures. Seed the DB with:
- A match in the matches table (match_id=99999, minimal required fields + scraped_at/source_url/parser_version provenance)
- Two maps in the maps table (match_id=99999, map_number=1, mapstatsid=111111) and (match_id=99999, map_number=2, mapstatsid=222222)
- A third map with mapstatsid=None (unplayed/forfeit) -- this should NOT appear in pending results

Tests:
- `test_returns_maps_without_player_stats`: After seeding match+maps (no player_stats yet), get_pending_map_stats returns 2 entries with correct match_id, map_number, mapstatsid
- `test_excludes_maps_with_player_stats`: Insert player_stats row for map 1, then get_pending_map_stats returns only map 2
- `test_excludes_null_mapstatsid`: The forfeit map (mapstatsid=None) is never returned
- `test_respects_limit`: With 2 pending maps, limit=1 returns only 1
- `test_returns_empty_when_all_processed`: After inserting player_stats for both maps, returns empty list
- `test_ordered_by_match_and_map`: Insert maps for two different matches, verify order is match_id ASC then map_number ASC

**TestUpsertMapStatsComplete:**

Setup: Seed DB with match and map as above.

Tests:
- `test_upserts_player_stats_and_rounds_atomically`: Call upsert_map_stats_complete with 5 player_stats dicts and 24 round dicts. Verify all 5 player_stats rows and all 24 round_history rows exist in DB.
- `test_rollback_on_round_error`: Provide valid player_stats but invalid round data (missing required field). Verify neither player_stats nor rounds were persisted (atomic rollback).
- `test_map_no_longer_pending_after_upsert`: After upsert_map_stats_complete, get_pending_map_stats no longer returns that map.

For test data, build minimal dicts matching the UPSERT_PLAYER_STATS and UPSERT_ROUND parameter names from repository.py. Use made-up but valid values (player_id=1001, kills=15, deaths=10, etc.). Include all required fields: match_id, map_number, player_id, player_name, team_id, kills, deaths, assists, flash_assists, hs_kills, kd_diff, adr, kast, fk_diff, rating_2, rating_3, kpr, dpr, impact, scraped_at, source_url, parser_version.

Run: `pytest tests/test_repository.py -v -k "pending_map_stats or map_stats_complete"`
  </action>
  <verify>
`pytest tests/test_repository.py -v` -- all tests pass (both existing and new), 0 failures.
  </verify>
  <done>
New repository methods tested: get_pending_map_stats correctly filters by mapstatsid presence and player_stats absence, respects limit, orders correctly. upsert_map_stats_complete writes atomically and rolls back on error. Existing tests still pass.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from scraper.config import ScraperConfig; c = ScraperConfig(); assert c.map_stats_batch_size == 10"` passes
2. `python -c "from scraper.repository import MatchRepository; assert hasattr(MatchRepository, 'get_pending_map_stats'); assert hasattr(MatchRepository, 'upsert_map_stats_complete')"` passes
3. `pytest tests/test_repository.py -v` -- all tests pass (old and new)
4. No existing tests broken by the additions
</verification>

<success_criteria>
- get_pending_map_stats returns maps with mapstatsid but no player_stats rows
- upsert_map_stats_complete atomically writes player_stats + round_history
- map_stats_batch_size config field defaults to 10
- All existing repository tests still pass
- New tests cover filtering, ordering, limit, atomicity, and rollback
</success_criteria>

<output>
After completion, create `.planning/phases/06-map-stats-extraction/06-02-SUMMARY.md`
</output>
