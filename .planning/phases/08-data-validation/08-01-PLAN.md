---
phase: 08-data-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/scraper/models/__init__.py
  - src/scraper/models/match.py
  - src/scraper/models/map.py
  - src/scraper/models/player_stats.py
  - src/scraper/models/round_history.py
  - src/scraper/models/economy.py
  - src/scraper/models/veto.py
  - src/scraper/models/match_player.py
  - src/scraper/models/kill_matrix.py
  - migrations/005_quarantine.sql
  - src/scraper/repository.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "Every database entity type has a corresponding Pydantic model with field-level type constraints"
    - "Forfeit matches have a separate lighter model that only validates fields that exist"
    - "Quarantine table exists in the database with match_id lookup and entity_type indexing"
    - "Quarantine records can be inserted via repository methods"
  artifacts:
    - path: "src/scraper/models/__init__.py"
      provides: "Re-exports all model classes"
      contains: "MatchModel"
    - path: "src/scraper/models/match.py"
      provides: "MatchModel and ForfeitMatchModel"
      exports: ["MatchModel", "ForfeitMatchModel"]
    - path: "src/scraper/models/player_stats.py"
      provides: "PlayerStatsModel with cross-field validators"
      exports: ["PlayerStatsModel"]
    - path: "src/scraper/models/round_history.py"
      provides: "RoundHistoryModel"
      exports: ["RoundHistoryModel"]
    - path: "src/scraper/models/economy.py"
      provides: "EconomyModel"
      exports: ["EconomyModel"]
    - path: "src/scraper/models/veto.py"
      provides: "VetoModel"
      exports: ["VetoModel"]
    - path: "src/scraper/models/match_player.py"
      provides: "MatchPlayerModel"
      exports: ["MatchPlayerModel"]
    - path: "src/scraper/models/kill_matrix.py"
      provides: "KillMatrixModel"
      exports: ["KillMatrixModel"]
    - path: "migrations/005_quarantine.sql"
      provides: "Quarantine table DDL"
      contains: "CREATE TABLE"
    - path: "src/scraper/repository.py"
      provides: "insert_quarantine method"
      contains: "insert_quarantine"
  key_links:
    - from: "src/scraper/models/__init__.py"
      to: "src/scraper/models/match.py"
      via: "re-export"
      pattern: "from .match import"
    - from: "src/scraper/repository.py"
      to: "migrations/005_quarantine.sql"
      via: "SQL INSERT"
      pattern: "INSERT INTO quarantine"
---

<objective>
Create Pydantic v2 validation models for all 8 database entity types plus a forfeit match variant, and set up the quarantine infrastructure for storing rejected records.

Purpose: Foundation for all validation -- models define what valid data looks like, quarantine stores what fails.
Output: 9 Pydantic model classes, quarantine migration, quarantine repository method, pydantic in pyproject.toml dependencies.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-data-validation/08-CONTEXT.md
@.planning/phases/08-data-validation/08-RESEARCH.md
@src/scraper/repository.py
@migrations/001_initial_schema.sql
@migrations/004_performance_economy.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pydantic models for all entity types</name>
  <files>
    src/scraper/models/__init__.py
    src/scraper/models/match.py
    src/scraper/models/map.py
    src/scraper/models/player_stats.py
    src/scraper/models/round_history.py
    src/scraper/models/economy.py
    src/scraper/models/veto.py
    src/scraper/models/match_player.py
    src/scraper/models/kill_matrix.py
    pyproject.toml
  </files>
  <action>
    Create `src/scraper/models/` package with one model file per database table. Use Pydantic v2 API throughout (BaseModel, Field, model_validator, NOT the deprecated v1 names).

    Add `"pydantic>=2.10"` to the `dependencies` list in `pyproject.toml`.

    **MatchModel** (match.py):
    - Fields from UPSERT_MATCH: match_id (gt=0), date (str), event_id (gt=0), event_name (min_length=1), team1_id (gt=0), team1_name (min_length=1), team2_id (gt=0), team2_name (min_length=1), team1_score (int|None=None), team2_score (int|None=None), best_of (ge=1, le=5), is_lan (ge=0, le=1), match_url (str|None=None), scraped_at (min_length=1), source_url (str|None=None), parser_version (str|None=None)
    - @model_validator check_scores_consistency: if both scores present, max(scores) <= (best_of+1)//2. If winner has fewer than max wins, warnings.warn (forfeit edge case)
    - @model_validator check_teams_different: team1_id != team2_id

    **ForfeitMatchModel** (match.py): Lighter model -- same fields but team1_score and team2_score have no cross-field checks. No score consistency check (forfeits have irregular scores).

    **MapModel** (map.py):
    - Fields from UPSERT_MAP: match_id (gt=0), map_number (ge=1, le=5), mapstatsid (int|None, gt=0), map_name (str), team1_rounds/team2_rounds (int|None, ge=0), team1_ct_rounds/team1_t_rounds/team2_ct_rounds/team2_t_rounds (int|None, ge=0), scraped_at (min_length=1), updated_at (str), source_url (str|None=None), parser_version (str|None=None)
    - @model_validator check_half_scores_sum: for each team, ct_rounds + t_rounds <= total_rounds (not ==, due to OT). Only check when all three values are not None.
    - Soft warning if team1_rounds + team2_rounds > 50 (extreme OT).

    **PlayerStatsModel** (player_stats.py):
    - All fields from UPSERT_PLAYER_STATS. Use ge=0 for count fields (kills, deaths, assists, flash_assists, hs_kills, opening_kills, opening_deaths, multi_kills, clutch_wins, traded_deaths). kd_diff and fk_diff can be negative (no ge). impact can be negative. round_swing can be negative. adr ge=0.0. kast ge=0.0 le=100.0. rating_2/rating_3/kpr/dpr/mk_rating ge=0.0.
    - @model_validator check_kd_diff_consistency: if kills, deaths, and kd_diff all present, kd_diff must equal kills-deaths
    - @model_validator check_fk_diff_consistency: if opening_kills, opening_deaths, and fk_diff all present, fk_diff must equal opening_kills-opening_deaths
    - @model_validator check_hs_kills_le_kills: if hs_kills and kills both present, hs_kills <= kills
    - @model_validator warn_unusual_values: warning for rating_2/rating_3 outside [0.1, 3.0], adr > 200.0

    **RoundHistoryModel** (round_history.py):
    - Fields from UPSERT_ROUND: match_id (gt=0), map_number (ge=1, le=5), round_number (ge=1), winner_side (str), win_type (str), winner_team_id (int|None), scraped_at (min_length=1), updated_at (str), source_url (str|None=None), parser_version (str|None=None)
    - @field_validator winner_side: must be "CT" or "T"
    - @field_validator win_type: must be in {"elimination", "bomb_planted", "defuse", "time"}

    **EconomyModel** (economy.py):
    - Fields from UPSERT_ECONOMY: match_id (gt=0), map_number (ge=1, le=5), round_number (ge=1), team_id (gt=0), equipment_value (int|None, ge=0), buy_type (str|None), scraped_at (min_length=1), updated_at (str), source_url (str|None=None), parser_version (str|None=None)
    - @field_validator buy_type: if not None, must be in {"full_eco", "semi_eco", "semi_buy", "full_buy"}

    **VetoModel** (veto.py):
    - Fields from UPSERT_VETO: match_id (gt=0), step_number (ge=1), team_name (str|None), action (str), map_name (str), scraped_at (min_length=1), updated_at (str), source_url (str|None=None), parser_version (str|None=None)
    - @field_validator action: must be in {"removed", "picked", "left_over"}

    **MatchPlayerModel** (match_player.py):
    - Fields from UPSERT_MATCH_PLAYER: match_id (gt=0), player_id (gt=0), player_name (str|None), team_id (int|None, gt=0), team_num (ge=1, le=2), scraped_at (min_length=1), updated_at (str), source_url (str|None=None), parser_version (str|None=None)

    **KillMatrixModel** (kill_matrix.py):
    - Fields from UPSERT_KILL_MATRIX: match_id (gt=0), map_number (ge=1, le=5), matrix_type (str), player1_id (gt=0), player2_id (gt=0), player1_kills (ge=0), player2_kills (ge=0), scraped_at (min_length=1), updated_at (str), source_url (str|None=None), parser_version (str|None=None)
    - @field_validator matrix_type: must be in {"all", "first_kill", "awp"}

    **__init__.py**: Re-export all model classes for convenient imports.

    **IMPORTANT -- do NOT use ConfigDict(strict=True)**. Existing code passes ints where floats are expected (e.g., adr=0). Pydantic's default coercion handles this.

    **IMPORTANT -- use `import warnings` inside validators** for soft warnings, not `logger.warning()`. The validation wrapper will catch and log warnings from a catch_warnings context.

    **IMPORTANT -- `updated_at: str` field**: Include it in all models but do NOT validate its value beyond type. The UPSERT SQL sets it via `excluded.scraped_at`. The orchestrator dicts currently don't pass `updated_at` explicitly -- the SQL handles it. So make `updated_at` optional with a default: `updated_at: str = ""`. The validation wrapper will fill this if needed before model_validate.
  </action>
  <verify>
    `python -c "from scraper.models import MatchModel, ForfeitMatchModel, MapModel, PlayerStatsModel, RoundHistoryModel, EconomyModel, VetoModel, MatchPlayerModel, KillMatrixModel; print('All models imported')"` succeeds.

    `python -c "from scraper.models import MatchModel; m = MatchModel.model_validate({'match_id': 1, 'date': '2024-01-01', 'event_id': 1, 'event_name': 'Test', 'team1_id': 1, 'team1_name': 'A', 'team2_id': 2, 'team2_name': 'B', 'best_of': 3, 'is_lan': 1, 'scraped_at': '2024-01-01T00:00:00'}); print(m.model_dump())"` returns a valid dict.
  </verify>
  <done>All 9 Pydantic model classes importable, field constraints enforced, cross-field validators active, pydantic in pyproject.toml dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Quarantine migration and repository method</name>
  <files>
    migrations/005_quarantine.sql
    src/scraper/repository.py
  </files>
  <action>
    **Migration file** (migrations/005_quarantine.sql):
    Create the quarantine table with these columns:
    - id: INTEGER PRIMARY KEY AUTOINCREMENT
    - entity_type: TEXT NOT NULL (model class name like "MatchModel", "PlayerStatsModel")
    - match_id: INTEGER (nullable -- for easy lookup)
    - map_number: INTEGER (nullable -- not all entities are per-map)
    - raw_data: TEXT NOT NULL (JSON dump of the dict that failed)
    - error_details: TEXT NOT NULL (str(ValidationError))
    - quarantined_at: TEXT NOT NULL (ISO 8601)
    - resolved: INTEGER DEFAULT 0 (0=pending, 1=resolved)

    Create indexes:
    - idx_quarantine_match ON quarantine(match_id)
    - idx_quarantine_type ON quarantine(entity_type)
    - idx_quarantine_resolved ON quarantine(resolved)

    **Repository extension** (src/scraper/repository.py):
    Add UPSERT_QUARANTINE (actually just INSERT -- quarantine rows are never updated, only appended) as a module-level SQL constant. Add `insert_quarantine(self, data: dict) -> None` method to MatchRepository. Also add `get_quarantine_count(self) -> int` for monitoring. The insert method should use `with self.conn:` for transaction.

    The `data` dict should have keys: entity_type, match_id, map_number, raw_data, error_details, quarantined_at, resolved.
  </action>
  <verify>
    Run `python -c "from scraper.db import Database; db = Database(':memory:'); db.initialize(); v = db.get_schema_version(); print(f'Schema version: {v}')"` -- should print version 5.

    Run `python -c "from scraper.db import Database; from scraper.repository import MatchRepository; db = Database(':memory:'); db.initialize(); repo = MatchRepository(db.conn); repo.insert_quarantine({'entity_type': 'test', 'match_id': 1, 'map_number': None, 'raw_data': '{}', 'error_details': 'test error', 'quarantined_at': '2024-01-01', 'resolved': 0}); print(f'Count: {repo.get_quarantine_count()}')"` -- should print "Count: 1".
  </verify>
  <done>Quarantine table created via migration 005, repository has insert_quarantine and get_quarantine_count methods, schema version increments to 5.</done>
</task>

</tasks>

<verification>
- All 9 model classes import successfully from `scraper.models`
- MatchModel rejects match_id=0, team1_id==team2_id, score exceeding best_of
- PlayerStatsModel rejects kd_diff inconsistent with kills-deaths
- RoundHistoryModel rejects winner_side="X" (must be CT/T)
- Quarantine table exists in schema version 5
- Repository can insert and count quarantine records
</verification>

<success_criteria>
- 9 Pydantic model classes covering all DB entity types
- Field constraints match the DB schema (correct types, ge/le bounds)
- Cross-field validators implemented for match scores, player stats consistency, half scores
- Soft warnings for unusual-but-valid values (extreme ratings, high ADR)
- Quarantine table with migration 005
- Repository methods for quarantine insert and count
- pydantic>=2.10 in pyproject.toml dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/08-data-validation/08-01-SUMMARY.md`
</output>
