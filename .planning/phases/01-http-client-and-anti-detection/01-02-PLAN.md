---
phase: 01-http-client-and-anti-detection
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/scraper/http_client.py
  - tests/test_http_client.py
autonomous: true

must_haves:
  truths:
    - "HLTVClient detects Cloudflare challenge pages by cf-mitigated header and HTML signatures"
    - "HLTVClient retries on CloudflareChallenge/RateLimited with exponential backoff via tenacity"
    - "HLTVClient does NOT retry on 404 (PageNotFound)"
    - "HLTVClient enforces rate limiting between requests via RateLimiter"
    - "HLTVClient maintains a single curl_cffi Session for cookie/connection persistence"
    - "HLTVClient backs off the rate limiter on failures and recovers on successes"
  artifacts:
    - path: "src/scraper/http_client.py"
      provides: "Complete HLTV HTTP client with anti-detection"
      contains: "class HLTVClient"
      min_lines: 80
    - path: "tests/test_http_client.py"
      provides: "Unit tests with mocked HTTP responses"
      min_lines: 60
  key_links:
    - from: "src/scraper/http_client.py"
      to: "src/scraper/rate_limiter.py"
      via: "RateLimiter.wait() called before each fetch"
      pattern: "rate_limiter\\.wait"
    - from: "src/scraper/http_client.py"
      to: "src/scraper/exceptions.py"
      via: "raises CloudflareChallenge, RateLimited, PageNotFound"
      pattern: "raise (CloudflareChallenge|RateLimited|PageNotFound)"
    - from: "src/scraper/http_client.py"
      to: "src/scraper/user_agents.py"
      via: "UserAgentRotator provides initial headers"
      pattern: "UserAgentRotator"
    - from: "src/scraper/http_client.py"
      to: "src/scraper/config.py"
      via: "ScraperConfig drives all parameters"
      pattern: "ScraperConfig"
---

<objective>
Build the HLTVClient class that wires together curl_cffi Session, RateLimiter, UserAgentRotator, Cloudflare challenge detection, and tenacity retry logic into a single `fetch(url)` method.

Purpose: This is the core HTTP transport for the entire scraper. Every subsequent phase uses `HLTVClient.fetch()` to get HLTV pages.
Output: Complete, tested HTTP client that handles rate limiting, UA rotation, Cloudflare detection, and retries.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-http-client-and-anti-detection/01-RESEARCH.md
@.planning/phases/01-http-client-and-anti-detection/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Cloudflare response checking and HLTVClient implementation</name>
  <files>
    src/scraper/http_client.py
  </files>
  <action>
Create `src/scraper/http_client.py` with two components:

**Component 1: Response checker function**

`_check_response(response) -> None` -- a module-level function that inspects a curl_cffi response and raises the appropriate exception:

Detection order (important -- check in this sequence):
1. Check `cf-mitigated` header == "challenge" -> raise `CloudflareChallenge` (most reliable Cloudflare detection, per official Cloudflare docs)
2. Check HTTP 429 -> raise `RateLimited` (include Retry-After header value in exception message if present)
3. Check HTTP 403 or 503 with HTML content type -> inspect first 2000 chars for Cloudflare HTML signatures: `"cf-chl-widget"`, `"challenge-platform"`, `"_cf_chl_opt"`, `"Checking your browser"`, `"Just a moment..."`. If any match -> raise `CloudflareChallenge`. If 403 without signatures -> still raise `CloudflareChallenge` (err on the side of caution). If 503 without signatures -> raise `CloudflareChallenge`.
4. Check HTTP 404 -> raise `PageNotFound`
5. Check any other HTTP >= 400 -> raise `HLTVFetchError`
6. If none of the above, response is valid -- return None.

**Component 2: HLTVClient class**

```python
class HLTVClient:
    def __init__(self, config: ScraperConfig | None = None):
        # Use ScraperConfig() defaults if None
        # Create curl_cffi.requests.Session with impersonate=config.impersonate_target, timeout=config.timeout
        # Create RateLimiter(config)
        # Create UserAgentRotator(config.impersonate_target)
        # Set initial UA headers on the session from rotator.get_headers()
        # Initialize counters: _request_count, _success_count, _challenge_count
```

Methods:

- `fetch(self, url: str) -> str`: The main method. Decorated with tenacity retry:
  - `retry=retry_if_exception_type((CloudflareChallenge, RateLimited, ConnectionError, TimeoutError, OSError))`
  - `wait=wait_exponential_jitter(initial=10, max=120, jitter=5)`
  - `stop=stop_after_attempt(config.max_retries)`
  - `before_sleep=before_sleep_log(logger, logging.WARNING)`

  Implementation:
  1. Call `self.rate_limiter.wait()`
  2. Increment `_request_count`
  3. Call `self.session.get(url)`
  4. Call `_check_response(response)`
  5. On success: call `self.rate_limiter.recover()`, increment `_success_count`, log debug, return `response.text`
  6. On `CloudflareChallenge` or `RateLimited`: call `self.rate_limiter.backoff()`, increment `_challenge_count`, re-raise (let tenacity handle retry)

- `close(self) -> None`: Close the session.
- `__enter__` / `__exit__`: Context manager support.
- Property `stats -> dict`: Return dict with requests, successes, challenges, success_rate, current_delay.

IMPORTANT DESIGN DECISIONS (from research):
- Use a SINGLE Session for the entire client lifetime. Do NOT create sessions per request.
- Do NOT override all headers -- only set the User-Agent via `session.headers.update()` to avoid disrupting curl_cffi's impersonation header order.
- The tenacity `@retry` decorator goes on the `fetch` method directly. Do NOT separate retry logic into a different module -- tenacity decorators are most readable inline.
- Include `OSError` in retry exceptions because curl_cffi raises `OSError` for connection resets and network failures (not `ConnectionError`).
- Log at DEBUG level for successes, WARNING level for retries (tenacity handles this via before_sleep_log).
  </action>
  <verify>
    Run `python -c "from scraper.http_client import HLTVClient; c = HLTVClient(); print(type(c.session)); c.close()"` -- no import errors, session type is curl_cffi Session.
  </verify>
  <done>
    HLTVClient class exists with fetch(), _check_response(), rate limiting integration, tenacity retry, and curl_cffi Session management.
  </done>
</task>

<task type="auto">
  <name>Task 2: HLTVClient unit tests with mocked HTTP responses</name>
  <files>
    tests/test_http_client.py
  </files>
  <action>
Create `tests/test_http_client.py` with thorough unit tests. Mock `curl_cffi.requests.Session.get` to return fake responses -- do NOT make real HTTP requests in unit tests.

Create a helper to build mock responses:

```python
class MockResponse:
    def __init__(self, status_code=200, text="<html>HLTV</html>", headers=None, url="https://www.hltv.org/test"):
        self.status_code = status_code
        self.text = text
        self.headers = headers or {"content-type": "text/html"}
        self.url = url
```

Tests (mock `time.sleep` and `Session.get`):

1. `test_fetch_success_returns_html` -- 200 response returns response.text
2. `test_fetch_success_increments_counters` -- after fetch, stats show 1 request, 1 success
3. `test_fetch_calls_rate_limiter_wait` -- verify rate_limiter.wait() is called before the HTTP request
4. `test_fetch_recovers_on_success` -- verify rate_limiter.recover() is called after successful fetch
5. `test_cloudflare_challenge_cf_mitigated_header` -- response with `cf-mitigated: challenge` header raises CloudflareChallenge
6. `test_cloudflare_challenge_html_signatures` -- 403 response with "Just a moment..." in body raises CloudflareChallenge
7. `test_rate_limited_429` -- 429 response raises RateLimited
8. `test_page_not_found_404` -- 404 response raises PageNotFound (NOT retried)
9. `test_fetch_backoff_on_challenge` -- on CloudflareChallenge, rate_limiter.backoff() is called
10. `test_retry_on_cloudflare_challenge` -- mock first call to raise CloudflareChallenge, second call to succeed. Verify fetch returns successfully (tenacity retried). Use `side_effect=[challenge_response, success_response]`.
11. `test_no_retry_on_page_not_found` -- mock 404 response. Verify PageNotFound is raised immediately (only 1 call to session.get, NOT retried).
12. `test_context_manager` -- `with HLTVClient() as client:` works and session is closed after.

IMPORTANT: When mocking, patch `time.sleep` to avoid actual waits (both the rate limiter sleep and tenacity wait between retries). Use `unittest.mock.patch` to mock `time.sleep` globally in each test, or mock `self.rate_limiter.wait` to be a no-op.

For retry tests, also set `max_retries=2` in config to keep tests fast, and mock the tenacity wait to be 0 to avoid test delays.
  </action>
  <verify>
    Run `python -m pytest tests/test_http_client.py -v --tb=short` -- all 12 tests pass.
  </verify>
  <done>
    12 unit tests covering: success path, counter tracking, rate limiter integration, Cloudflare detection (header + HTML), rate limiting, 404 handling, backoff behavior, retry behavior, no-retry on 404, and context manager.
  </done>
</task>

</tasks>

<verification>
Run the full test suite to verify no regressions from Plan 01:

```bash
python -m pytest tests/ -v --tb=short
```

All tests from Plan 01 (rate_limiter, user_agents) and Plan 02 (http_client) pass.

Verify the client can be instantiated and wires correctly:

```python
python -c "
from scraper.http_client import HLTVClient
with HLTVClient() as client:
    print('Stats:', client.stats)
    print('Session type:', type(client.session).__name__)
    print('Rate limiter delay:', client.rate_limiter.current_delay)
print('Client closed successfully')
"
```
</verification>

<success_criteria>
- HLTVClient.fetch() makes HTTP requests through curl_cffi Session with impersonation
- _check_response detects Cloudflare via cf-mitigated header and HTML signatures
- Tenacity retries on CloudflareChallenge and RateLimited but NOT on PageNotFound
- RateLimiter.wait() is called before every request, backoff() on failures, recover() on success
- All 12 unit tests pass with mocked HTTP responses (no network calls)
- Full test suite (Plans 01 + 02) passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/01-http-client-and-anti-detection/01-02-SUMMARY.md`
</output>
